## 5. Conclusion

### 5.1. Problems and Delays

Throughout the project we encountered several challenges with drawing being our main obstacle. Specifically, implementing the XPM draw function initially consumed a great part of time as we were unaware that it was necessary to use the memcpy function. Another considerable challenge was drawing the mouse cursor as it left a trail and erased elements behind it. Implementing a triple buffer system, as mentioned previously, effectively resolved our problem. 

Moreover, since the beginning of the semester Minix could only run in a beta mode on silicon processors. Fortunately this didn't present as a problem, however, during the projects development final stages the program ceased to run on these computers posing a significant setback.

### 5.2. Future Works

In case we were to continue developing this project, we would like to add power-ups throughout the map, as well as increasing the number of rooms through which the Prince must pass.

Furthermore, it would be interesting to develop a multiplayer game mode, in which the other player would control the thief, and interact in the Fighting Screen. Actually, this was initially planned, but had to be set aside, due to the difficulties mentioned in the previous subsection.

### 5.3. Main Achievements

This project has given us the opportunity to implement custom peripherals following a specific set of requirements. Taking into account the content lectured in classes and our game's requirements we were able to successfully create functional peripherals that not only seamlessly integrate with the main system but have a pivotal importance to it's proper running. 

### 5.4. Lessons Learned

Ultimately this project provided us with a practical and enriching learning experience enabling us to gain a deeper understanding of the underlying principles and challenges involved when integrating software to hardware components. Challenges faced during the development of this project emphasis the importance of attention to detail and meticulous debugging due to the complexities of low-level programming.